% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Courier New}
  \setmonofont[]{Courier New}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Complete System Flow},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Complete System Flow}
\author{}
\date{\vspace{-2.5em}}

\begin{document}
\maketitle

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 1: Read Planning Team's Decisions â”‚ â”‚ Cell 6: Load
pending\_actions.json â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 2: Initialize Executive Team (3 Agents) â”‚ â”‚ Cell 8: Create Ops
Commander, Quality \& Safety, Infrastructure â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“ â”‚
Step 1: Load core agent modules â”‚ â”‚ â”œâ”€â†’ Import multi-agent orchestration
system â”‚ â”‚ â”œâ”€â†’ Load model configs, environment variables (.env) â”‚ â”‚ â””â”€â†’
Mount MLflow + Drive paths â”‚ â”‚ â”‚ â”‚ Step 2: Create Agents â”‚ â”‚ â”œâ”€â†’ ğŸ§­ Ops
Commander -- implementation \& code generation â”‚ â”‚ â”œâ”€â†’ ğŸ§© Quality \&
Safety -- logic review \& compliance check â”‚ â”‚ â””â”€â†’ âš™ï¸ Infrastructure --
runtime \& resource validation â”‚ â”‚ â”‚ â”‚ Step 3: Assign Structured Output
Contracts â”‚ â”‚ â”œâ”€â†’ Each agent emits JSON schema \{verdict, flags,
checks\ldots\} â”‚ â”‚ â””â”€â†’ Ensures downstream gating uses typed fields, not
text â”‚ â”‚ â”‚ â”‚ Step 4: Environment \& Dependency Check â”‚ â”‚ â”œâ”€â†’ Verify all
required APIs and credentials loaded â”‚ â”‚ â”œâ”€â†’ Confirm MLflow tracking URI
reachable â”‚ â”‚ â””â”€â†’ Confirm storage \& logging directories exist â”‚ â”‚ â”‚ â”‚
Step 5: READY Verification â”‚ â”‚ â”œâ”€â†’ All 3 agents must return status =
``READY'' â”‚ â”‚ â””â”€â†’ If any agent fails, halt initialization â”‚ â”‚ â”‚ â”‚
OUTPUT: Initialization log written to â”‚ â”‚
/multi-agent/logs/system\_init/exec\_team\_init.log â”‚ â”‚ â”‚ â”‚ â†’ Continue
to Phase 3: Approval Gate once all agents READY âœ… â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel System: Reflection Service (runs during Phases 3--6) Emits â†’
reflections.jsonl \textbar{} job\_spec\_patch.json \textbar{}
risk\_scores.json Consumed by â†’ Phase 3.5 (Approval Retry), 4.5 (Exec
Retry), 6.5 (Verification Retry)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

\begin{verbatim}
                       â†“
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 3: Task Implementation \& Agent Response Collection â”‚ â”‚ (No
execution -- agents produce drafts + structured contracts) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Listening Layer (R0: Signal Subscription) â€¢
Subscribes to live agent responses and inter-agent discrepancies â€¢
Captures early reasoning traces, draft risk flags, and schema quality â€¢
Streams to Reflection Service (Phases R1--R2) for pre-approval
diagnostics
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â†“ â”‚
FOR EACH TASK (HIGH â†’ MEDIUM â†’ LOW priority): â”‚ â”‚ â”‚ â”‚ Step 1: Dispatch
task to 3 agents â”‚ â”‚ â”œâ”€â†’ Ops Commander -- ``Propose implementation (code
as text)'' â”‚ â”‚ â”œâ”€â†’ Quality \& Safety -- ``Assess logic \& risks'' â”‚ â”‚
â””â”€â†’ Infrastructure -- ``Assess env/resources \& performance'' â”‚ â”‚ â”‚ â”‚
Step 2: Agents respond (no execution) â”‚ â”‚ â”œâ”€â†’ Ops Commander: draft
Python/code + rationale â”‚ â”‚ â”œâ”€â†’ Quality \& Safety: review notes \& risk
flags â”‚ â”‚ â””â”€â†’ Infrastructure: resource/perf analysis â”‚ â”‚ (All 3 emit
\textbf{structured JSON contracts} + commentary) â”‚ â”‚ Contract schema
(example): â”‚ â”‚ \{ verdict, flags:\{critical{[}{]}, warnings{[}{]}\}, â”‚ â”‚
checks:\{requirements\_passed, mlflow\_required\}, â”‚ â”‚
proposed\_jobs:{[}\{id, entry, args, expected\_artifacts\}{]} \} â”‚ â”‚ â”‚ â”‚
Step 3: Emit Reflection Snapshot (Async Event) â”‚ â”‚ â”œâ”€â†’ Publish
mini-event to reflection\_stream: â”‚ â”‚ \{task\_id,
phase:``implementation'', risk\_flags, divergence\} â”‚ â”‚ â”œâ”€â†’ Enables
early pattern detection (R2: Error \& Signal Mining) â”‚ â”‚ â””â”€â†’ Logged to
reflections.jsonl with timestamp \& checksum â”‚ â”‚ â”‚ â”‚ END FOR EACH TASK â”‚
â”‚ â”‚ â”‚ OUTPUT â†’ task\_drafts = {[} â”‚ â”‚ \{task
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 4: APPROVAL (Cell 11) â”‚ â”‚ 3-Agent Approval Gate -- Contract-Driven
Decision â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Listening Layer (R0: Signal Subscription) â€¢
Subscribes to real-time Approval logs (verdicts, flags, rationale) â€¢
Streams non-blocking events â†’ Reflection Service (Phases 3--6) â€¢ Used to
trigger early diagnostic signals and confidence updates
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”‚ FOR EACH task\_draft: â”‚ â”‚ â”‚ â”‚ Step 1: Gate on structured verdicts â”‚ â”‚
â”œâ”€â†’ Ops Commander verdict == ``APPROVE''? â”‚ â”‚ â”œâ”€â†’ Quality \& Safety
verdict == ``APPROVE''? â”‚ â”‚ â””â”€â†’ Infrastructure verdict == ``APPROVE''? â”‚
â”‚ Decision uses \textbf{explicit JSON fields}, not text search â”‚ â”‚ â”‚ â”‚
Step 2: Apply strict rule â”‚ â”‚ â”œâ”€â†’ IF (all three APPROVE) AND (no
critical flags) â†’ â”‚ â”‚ â”‚ preliminary\_status = ``approved'' â”‚ â”‚ â””â”€â†’ ELSE
â†’ preliminary\_status = ``rejected'' â”‚ â”‚ â”‚ â”‚ Step 3: Persist decision â”‚
â”‚ â””â”€â†’ Store \{task\_id, preliminary\_status, contracts, reasons,
approved\_jobs{[}{]}\} â”‚ â”‚ (No execution here --- handoff to Phase 5:
Execution) â”‚ â”‚ (If rejected â†’ send to Phase 4.5 Approval Retry) â”‚ â”‚ â”‚ â”‚
Step 4: Emit reflection signal snapshot â”‚ â”‚ â”œâ”€â†’ Publish minimal event â†’
reflection\_stream: â”‚ â”‚ \{task\_id, phase: ``approval'', verdicts,
flags, status\} â”‚ â”‚ â”œâ”€â†’ Enables reflection R1--R2 modules to start
root-cause mining â”‚ â”‚ â””â”€â†’ Logged to reflections.jsonl with timestamp \&
checksum â”‚ â”‚ â”‚ â”‚ END FOR EACH â”‚ â”‚ â”‚ â”‚ OUTPUT â†’ task\_results = {[} â”‚ â”‚
\{task\_id: 1, preliminary\_status: ``approved'',
approved\_jobs\ldots\}, â”‚ â”‚ \{task\_id: 2, preliminary\_status:
``rejected'', reasons\ldots\}, â”‚ â”‚ \ldots{} â”‚ â”‚ {]}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                         â†“
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 4.5: Approval Retry Mechanism â”‚ â”‚ (Triggered when any agent
rejects or flags critical issues) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“ â”‚
FOR EACH task\_result WHERE preliminary\_status == ``rejected'': â”‚ â”‚ â”‚ â”‚
Step 1: Collect Reflection Feedback â”‚ â”‚ â”œâ”€â†’ Pull from Reflection
Service: â”‚ â”‚ â”‚ â€¢ reflections.jsonl (notes \& root-cause) â”‚ â”‚ â”‚ â€¢
job\_spec\_patch.json (safe diffs for plan/args/env) â”‚ â”‚ â”‚ â€¢
risk\_scores.json (confidence, severity, cost) â”‚ â”‚ â””â”€â†’ Parse:
failure\_reason, proposed\_fix, confidence\_score â”‚ â”‚ â”‚ â”‚ Step 2: Retry
Eligibility Gate â”‚ â”‚ â”œâ”€â†’ IF confidence\_score â‰¥ Ï„ (default 0.70) â†’
proceed â”‚ â”‚ â”œâ”€â†’ ELSE â†’ mark non-retriable; log reason; continue to Phase
7 â”‚ â”‚ â””â”€â†’ Enforce guardrails (no permission scope expansion, etc.) â”‚ â”‚ â”‚
â”‚ Step 3: Apply Patch (Sandboxed) â”‚ â”‚ â”œâ”€â†’ Merge job\_spec\_patch.json
into task draft (safe diff-scan) â”‚ â”‚ â”œâ”€â†’ Update contract metadata:
retry\_attempt += 1 â”‚ â”‚ â””â”€â†’ Generate provenance IDs (attempt\_id,
patch\_id, checksum) â”‚ â”‚ â”‚ â”‚ Step 4: Re-submit to Approval Gate â”‚ â”‚ â”œâ”€â†’
Send revised draft back to the 3 agents (Ops/Quality/Infra)â”‚ â”‚ â”œâ”€â†’ Run
Phase 4 checks (explicit verdict fields, flags) â”‚ â”‚ â””â”€â†’ Persist new
verdicts under attempt\_id + timestamp â”‚ â”‚ â”‚ â”‚ Step 5: Limit Enforcement
â”‚ â”‚ â”œâ”€â†’ IF retry\_attempt \textgreater{} MAX\_RETRIES (default = 2) â†’
abort â”‚ â”‚ â””â”€â†’ Record terminal reason: ``Exceeded retry limit'' â”‚ â”‚ â”‚ â”‚
Step 6: Artifact Emission \& Traceability (Reflection Output) â”‚ â”‚ â”œâ”€â†’
Emit to /ledgers/ and /memory/: â”‚ â”‚ â”‚ â€¢ /ledgers/reflections.jsonl
(append attempt record) â”‚ â”‚ â”‚ â€¢ /patches/job\_spec\_patch.json (applied
patch snapshot) â”‚ â”‚ â”‚ â€¢ /ledgers/risk\_scores.json (decision features) â”‚
â”‚ â”‚ â€¢ /ledgers/contract\_delta.json (preâ†’post gate diff) â”‚ â”‚ â”‚ â€¢
/ledgers/patch\_applied.diff (unified diff) â”‚ â”‚ â”œâ”€â†’ Link MLflow evidence
if any pre-check runs were simulated: â”‚ â”‚ â”‚ â€¢ mlflow.link: \{task\_id,
attempt\_id, related\_run\_ids{[}{]}\} â”‚ â”‚ â””â”€â†’ Update memory for
learning: â”‚ â”‚ â€¢ /memory/episodic.jsonl (attempt-level reflection) â”‚ â”‚ â€¢
/memory/semantic.yml (if pattern recurs â†’ rule) â”‚ â”‚ â€¢
/memory/procedural\_cache/ (if patch stabilizes) â”‚ â”‚ â”‚ â”‚ END FOR EACH â”‚
â”‚ â”‚ â”‚ OUTPUT â†’ updated\_task\_results = {[} â”‚ â”‚ \{task\_id: 1,
retry\_attempts: 1, status: ``approved\_after\_patch''\},â”‚ â”‚ \{task\_id:
2, retry\_attempts: 2, status: ``failed\_final''\}, â”‚ â”‚ \ldots{} â”‚ â”‚ {]}
â”‚ â”‚ â”‚ â”‚ NOTE: All emitted artifacts are batch-flushed and versioned; â”‚ â”‚
checksums enable end-to-end provenance from reflection â†’ gate. â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                        â†“
                        
                        
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 5: EXECUTION (Cell 11.5) â”‚ â”‚ Automatic Code Executor -- Run
Approved Plans â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Listening Layer (R0: Signal Subscription) â€¢
Subscribes to runtime logs (stdout/stderr), exit codes, MLflow â€¢ Streams
non-blocking telemetry â†’ Reflection Service (R1--R6) â€¢ Enables rapid
root-cause mining before 5.5 retry
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â†“ â”‚
FOR EACH task\_result IN task\_results: â”‚ â”‚ â”‚ â”‚ Step 1: Check
Preliminary Status â”‚ â”‚ â”œâ”€â†’ If preliminary\_status != ``approved'' â†’ Skip
(â­ï¸) â”‚ â”‚ â””â”€â†’ Else â†’ Continue to execution â”‚ â”‚ â”‚ â”‚ Step 2: Retrieve Job
Specification â”‚ â”‚ â”œâ”€â†’ Extract from Ops Commander's structured JSON â”‚ â”‚
â”œâ”€â†’ job\_spec = \{entry, args, expected\_artifacts, env\_keys{[}{]}\} â”‚
â”‚ â””â”€â†’ Verify all required artifacts \& MLflow keys declared â”‚ â”‚ â”‚ â”‚ Step
3: Safe Job Execution (Sandboxed) â”‚ â”‚ â”œâ”€â†’ Spawn isolated
subprocess/container â”‚ â”‚ â”œâ”€â†’ Apply timeouts, CPU/GPU/memory quotas â”‚ â”‚
â”œâ”€â†’ Stream stdout/stderr â†’ /logs/execution\_cycles/\ldots{} â”‚ â”‚ â”œâ”€â†’
Capture telemetry lines: â”‚ â”‚ â”‚ MLFLOW\_RUN\_ID=\ldots, ARTIFACT=\ldots,
METRIC=\ldots{} â”‚ â”‚ â”œâ”€â†’ On crash â†’ tag as RETRYABLE\_FAILURE or ERROR â”‚
â”‚ â””â”€â†’ No direct \texttt{exec()} in kernel (security isolation) â”‚ â”‚ â”‚ â”‚
Step 4: Record Execution Results â”‚ â”‚ â”œâ”€â†’ execution.status = SUCCEEDED
\textbar{} FAILED \textbar{} RETRYABLE\_FAILURE â”‚ â”‚ â”œâ”€â†’ Persist run\_id,
artifacts{[}{]}, metrics\{\} â”‚ â”‚ â”œâ”€â†’ Update task\_result with telemetry
+ log path â”‚ â”‚ â””â”€â†’ Append ledger: /multi-agent/ledgers/run\_log.json â”‚ â”‚
â”‚ â”‚ Step 5: Post-Execution Routing â”‚ â”‚ â”œâ”€â†’ IF execution.status ==
SUCCEEDED â†’ â”‚ â”‚ â”‚ â€¢ Emit success snapshot â†’ reflection\_stream
(non-block) â”‚ â”‚ â”‚ â€¢ Mark executed\_ready\_for\_verification = True â”‚ â”‚ â”‚
â€¢ Enqueue to Phase 6: Verification â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â†’ IF execution.status âˆˆ
\{FAILED, RETRYABLE\_FAILURE\} â†’ â”‚ â”‚ â€¢ Emit failure snapshot â†’
reflections.jsonl â”‚ â”‚ â€¢ Include: exit\_code, stderr\_tail, run\_id?,
artifacts â”‚ â”‚ â€¢ Route to Phase 5.5: Reflection-Guided Retry â”‚ â”‚ â€¢
Increment attempt counter (attempt\_id += 1) â”‚ â”‚ â”‚ â”‚ END FOR EACH â”‚ â”‚ â”‚
â”‚ OUTPUT: â”‚ â”‚ â€¢ Successful jobs â†’ queued for Phase 6 (Verification) â”‚ â”‚
â€¢ Unsuccessful jobs â†’ routed to Phase 5.5 (Retry) with â”‚ â”‚ complete
telemetry for reflection (patch + risk scoring) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                        â†“
                        
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 5.5: Reflection-Guided Retry (During Execution) â”‚ â”‚ (Triggered
when Phase 5 status âˆˆ \{FAILED, RETRYABLE\_FAILURE\}) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“ â”‚
FOR EACH failed\_attempt FROM Phase 5: â”‚ â”‚ â”‚ â”‚ Step 1: Collect
Reflection Outputs â”‚ â”‚ â”œâ”€â†’ Pull artifacts from Reflection Service: â”‚ â”‚ â”‚
â€¢ reflections.jsonl (root cause, notes) â”‚ â”‚ â”‚ â€¢ job\_spec\_patch.json
(safe diffs: args/code/env) â”‚ â”‚ â”‚ â€¢ risk\_scores.json (confidence,
severity, cost) â”‚ â”‚ â””â”€â†’ Parse: failure\_reason, proposed\_fix,
confidence\_score â”‚ â”‚ â”‚ â”‚ Step 2: Eligibility \& Guardrails â”‚ â”‚ â”œâ”€â†’
Require confidence\_score â‰¥ Ï„ (default 0.70) â”‚ â”‚ â”œâ”€â†’ Enforce safety: no
permission scope expansion, â”‚ â”‚ â”‚ no network/domain list changes, no
write-path widening â”‚ â”‚ â””â”€â†’ If not eligible â†’ skip retry; mark for Phase
7 reporting â”‚ â”‚ â”‚ â”‚ Step 3: Apply Patch (Versioned + Sandboxed) â”‚ â”‚ â”œâ”€â†’
Merge job\_spec\_patch.json â†’ new job\_spec\_v\{n+1\} â”‚ â”‚ â”œâ”€â†’ Generate
provenance IDs: attempt\_id, patch\_id, checksum â”‚ â”‚ â””â”€â†’ Diff-scan \&
sign patch; persist under /patches/ â”‚ â”‚ â”‚ â”‚ Step 4: Retry Execution
(Isolated) â”‚ â”‚ â”œâ”€â†’ Run in the same sandbox constraints (timeouts/quotas)
â”‚ â”‚ â”œâ”€â†’ Stream logs; capture MLflow run\_id, metrics, artifacts â”‚ â”‚ â”œâ”€â†’
On success â†’ tag as RETRY\_SUCCEEDED â”‚ â”‚ â””â”€â†’ On failure â†’ tag as
RETRY\_FAILED â”‚ â”‚ â”‚ â”‚ Step 5: Regression \& Rollback Check â”‚ â”‚ â”œâ”€â†’
Compare key metrics/artifacts vs previous attempt â”‚ â”‚ â”œâ”€â†’ If regression
detected (lower quality / missing files) â”‚ â”‚ â”‚ â†’ rollback to last best
artifacts; keep retry outcome log â”‚ â”‚ â””â”€â†’ Store regression\_reason in
run ledger â”‚ â”‚ â”‚ â”‚ Step 6: Loop Control â”‚ â”‚ â”œâ”€â†’ If RETRY\_SUCCEEDED â†’
enqueue to Phase 6 (Verification) â”‚ â”‚ â”œâ”€â†’ Else if attempts â‰¥
MAX\_EXEC\_RETRIES (default = 2) â”‚ â”‚ â”‚ â†’ stop; mark ``failed\_final'';
escalate in Phase 7 â”‚ â”‚ â””â”€â†’ Else â†’ request fresh reflection; iterate
again â”‚ â”‚ â”‚ â”‚ Step 7: Artifact Emission \& Memory Update â”‚ â”‚ â”œâ”€â†’ Emit: â”‚
â”‚ â”‚ â€¢ /ledgers/reflections.jsonl (attempt snapshot) â”‚ â”‚ â”‚ â€¢
/ledgers/risk\_scores.json (decision features) â”‚ â”‚ â”‚ â€¢
/patches/job\_spec\_patch.json (applied patch copy) â”‚ â”‚ â”‚ â€¢
/ledgers/run\_log.json (append retry run) â”‚ â”‚ â”œâ”€â†’ Link MLflow:
\{task\_id, attempt\_id, run\_id(s)\} â”‚ â”‚ â””â”€â†’ Update memory: â”‚ â”‚ â€¢
/memory/episodic.jsonl (attempt-level record) â”‚ â”‚ â€¢ /memory/semantic.yml
(add rule if pattern recurs) â”‚ â”‚ â€¢ /memory/procedural\_cache/ (store
stable template) â”‚ â”‚ â”‚ â”‚ END FOR EACH â”‚ â”‚ â”‚ â”‚ OUTPUT â†’ retry\_results =
{[} â”‚ â”‚ \{task\_id: T1, attempt: 2, status: ``RETRY\_SUCCEEDED'',
run\_id\ldots\},â”‚ â”‚ \{task\_id: T2, attempt: 3, status:
``failed\_final'', reasons\ldots\}, â”‚ â”‚ \ldots{} â”‚ â”‚ {]} â”‚ â”‚ NOTE: All
retries remain sandboxed; every iteration must change â”‚ â”‚ job\_spec (no
identical reruns). Confidence Ï„ \& max retriesâ”‚ â”‚ are configurable per
task class/priority. â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                         â†“
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 6: VERIFICATION (Cell 17) â”‚ â”‚ Evidence Check -- Verify Real
Results Exist â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Listening Layer (R0: Signal Subscription) â€¢
Subscribes to MLflow telemetry \& artifact validation events â€¢ Streams
non-blocking verification logs â†’ Reflection Service (R1--R6) â€¢ Enables
early detection of missing runs or incomplete outputs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â†“ â”‚
FOR EACH task WITH preliminary\_status == ``approved'': â”‚ â”‚ â”‚ â”‚ Step 1:
Determine Task Type â”‚ â”‚ â”œâ”€â†’ EXPERIMENTAL? (execute, run, diagnostic,
gpu, model) â†’ â”‚ â”‚ â”‚ Requires MLflow run\_id + declared result artifacts
â”‚ â”‚ â””â”€â†’ DOCUMENTATION? (write, design, draft, doc) â†’ â”‚ â”‚ Requires output
files only (MLflow optional) â”‚ â”‚ â”‚ â”‚ Step 2: Verify MLflow Evidence (if
required) â”‚ â”‚ â”œâ”€â†’ Retrieve run\_id from structured telemetry â”‚ â”‚ â”œâ”€â†’
Query MLflow: mlflow.get\_run(run\_id) â”‚ â”‚ â”œâ”€â†’ If run exists â†’ âœ…
Evidence confirmed â”‚ â”‚ â””â”€â†’ If missing or invalid â†’ âŒ Evidence missing â”‚
â”‚ â”‚ â”‚ Step 3: Verify Artifact Evidence â”‚ â”‚ â”œâ”€â†’ Load
expected\_artifacts{[}{]} from task\_result schema â”‚ â”‚ â”œâ”€â†’ For each
path: Path.exists() and size \textgreater{} 0 ? â”‚ â”‚ â”œâ”€â†’ If all exist â†’
âœ… Files verified â”‚ â”‚ â””â”€â†’ If any missing â†’ âŒ Incomplete evidence â”‚ â”‚ â”‚
â”‚ Step 4: Combine Results â†’ Verification Verdict â”‚ â”‚ â”œâ”€â†’ If all required
evidence present â†’ verification = ``pass'' â”‚ â”‚ â””â”€â†’ Else â†’ verification =
``fail'' â”‚ â”‚ â”‚ â”‚ Step 5: Emit Reflection Snapshot â”‚ â”‚ â”œâ”€â†’ Publish
\{task\_id, phase:``verification'', status, missing{[}{]}\} â”‚ â”‚ â†’
reflection\_stream for post-run analysis â”‚ â”‚ â””â”€â†’ Logged to
reflections.jsonl with timestamp \& checksum â”‚ â”‚ â”‚ â”‚ Step 6: Routing â”‚ â”‚
â”œâ”€â†’ If verification == ``pass'' â†’ continue to Phase 7 â”‚ â”‚ â””â”€â†’ If
verification == ``fail'' â†’ send to Phase 6.5 (Retry) â”‚ â”‚ â”‚ â”‚ END FOR
EACH â”‚ â”‚ â”‚ â”‚ OUTPUT: Structured verification report per approved task â”‚
â”‚ \{task\_id, verification:``pass''\textbar{}``fail'',
evidence:\{\ldots\}\} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                        â†“
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 6.5: Verification Retry Mechanism â”‚ â”‚ (Triggered when verification
== ``fail'') â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†“ â”‚
FOR EACH task FAILED VERIFICATION: â”‚ â”‚ â”‚ â”‚ Step 1: Collect Reflection
Outputs â”‚ â”‚ â”œâ”€â†’ Pull from Reflection Service: â”‚ â”‚ â”‚ â€¢ reflections.jsonl
(missing artifacts, failure notes) â”‚ â”‚ â”‚ â€¢ job\_spec\_patch.json
(regenerate logic / fix targets) â”‚ â”‚ â”‚ â€¢ risk\_scores.json (confidence,
severity, cost) â”‚ â”‚ â””â”€â†’ Parse root cause and confidence score â”‚ â”‚ â”‚ â”‚
Step 2: Eligibility Check â”‚ â”‚ â”œâ”€â†’ If confidence â‰¥ Ï„ (default 0.7) â†’
continue â”‚ â”‚ â””â”€â†’ Else â†’ mark non-retriable; log reason; Phase 7 â”‚ â”‚ â”‚ â”‚
Step 3: Rebuild Artifacts / Re-Query Evidence (Sandboxed) â”‚ â”‚ â”œâ”€â†’ Apply
patch to job\_spec or re-run MLflow query â”‚ â”‚ â”œâ”€â†’ Regenerate missing
files from cached inputs or logs â”‚ â”‚ â””â”€â†’ Capture new run\_id and
artifacts â”‚ â”‚ â”‚ â”‚ Step 4: Verification Re-Check â”‚ â”‚ â”œâ”€â†’ Repeat Phase 6
steps (MLflow + artifact validation) â”‚ â”‚ â””â”€â†’ If all pass â†’ mark
``verification\_passed\_after\_retry'' â”‚ â”‚ â”‚ â”‚ Step 5: Limit and
Escalation â”‚ â”‚ â”œâ”€â†’ If retry\_attempt \textgreater{} MAX\_VERIF\_RETRIES
(default = 2) â†’ abort â”‚ â”‚ â””â”€â†’ Store terminal reason = ``Verification
failed after retries''â”‚ â”‚ â”‚ â”‚ Step 6: Artifact Emission \& Memory Update
â”‚ â”‚ â”œâ”€â†’ Emit to ledgers/: â”‚ â”‚ â”‚ â€¢ reflections.jsonl (verification retry
record) â”‚ â”‚ â”‚ â€¢ risk\_scores.json (updated confidence) â”‚ â”‚ â”‚ â€¢
verification\_log.json (full validation trace) â”‚ â”‚ â””â”€â†’ Update /memory/:
â”‚ â”‚ â€¢ episodic.jsonl (attempt-level) â”‚ â”‚ â€¢ semantic.yml (new pattern
rule) â”‚ â”‚ â€¢ procedural\_cache/ (stable check templates) â”‚ â”‚ â”‚ â”‚ END FOR
EACH â”‚ â”‚ â”‚ â”‚ OUTPUT â†’ verification\_retry\_results = {[} â”‚ â”‚
\{task\_id:T1, attempt:2,
status:``verification\_passed\_after\_retry''\},â”‚ â”‚ \{task\_id:T2,
attempt:3, status:``failed\_final''\} \ldots{} {]} â”‚ â”‚ NOTE: All
verification retries remain sandboxed; evidence must â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\begin{verbatim}
                        â†“
\end{verbatim}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 7: FINAL STATUS DETERMINATION (Cell 17) â”‚ â”‚ Retroactive Status
Assignment Based on Verification \& Retries â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Snapshot (non-blocking) â€¢ Publish terminal event â†’
reflection\_stream: \{task\_id, phase:``finalize'', final\_status,
reasons{[}{]}, attempts\}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â†“ â”‚
FOR EACH task\_result: â”‚ â”‚ â”‚ â”‚ Step 1: Normalize Upstream Signals â”‚ â”‚
â”œâ”€â†’ Read: preliminary\_status, verification
(pass\textbar fail\textbar na), â”‚ â”‚ â”‚ retry\_summaries\{approval, exec,
verify\}, attempts.count â”‚ â”‚ â”œâ”€â†’ Derive flags: â”‚ â”‚ â”‚
approved\_after\_patch?, retry\_exhausted?, evidence\_ready?â”‚ â”‚ â””â”€â†’
Ingest last reflection note (if present) for context â”‚ â”‚ â”‚ â”‚ Step 2:
Terminal Status Rules (ordered) â”‚ â”‚ â”œâ”€â†’ IF preliminary\_status ==
``rejected'' â”‚ â”‚ â”‚ â†’ final\_status = ``failed'' â”‚ â”‚ â”‚ â†’ reason = ``Did
not pass 3-agent approval gate'' â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â†’ ELIF verification ==
``pass'' â”‚ â”‚ â”‚ â†’ final\_status = ``completed'' â”‚ â”‚ â”‚ â†’ reason =
(approved\_after\_patch? â”‚ â”‚ â”‚ ``Approved after retry + evidence
verified'' : â”‚ â”‚ â”‚ ``Approved + evidence verified'') â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â†’ ELIF
verification == ``fail'' AND retry\_exhausted == true â”‚ â”‚ â”‚ â†’
final\_status = ``failed\_final'' â”‚ â”‚ â”‚ â†’ reason = ``Evidence missing
after max retries'' â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â†’ ELIF verification == ``fail'' â”‚ â”‚ â”‚ â†’
final\_status = ``failed'' â”‚ â”‚ â”‚ â†’ reason = ``Approved but no evidence
(execution failed)''â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â†’ ELSE (fallback) â”‚ â”‚ final\_status =
``failed'' â”‚ â”‚ reason = ``Unresolved state; see logs'' â”‚ â”‚ â”‚ â”‚ Step 3:
Persist Canonical Close-Out Record â”‚ â”‚ â”œâ”€â†’ task\_result{[}`status'{]} =
final\_status â”‚ â”‚ â”œâ”€â†’ task\_result{[}`status\_reason'{]} = reason â”‚ â”‚
â”œâ”€â†’ task\_result{[}`attempts\_total'{]} = attempts.count â”‚ â”‚ â”œâ”€â†’
task\_result{[}`provenance'{]} = \{ â”‚ â”‚ â”‚
approval:\{approved\_after\_patch,
attempts:retry\_summaries.approval\},â”‚ â”‚ â”‚
execution:\{attempts:retry\_summaries.exec\}, â”‚ â”‚ â”‚
verification:\{attempts:retry\_summaries.verify\}, â”‚ â”‚ â”‚
mlflow\_run\_ids: {[}\ldots{]}, artifacts: {[}\ldots{]}, â”‚ â”‚ â”‚
reflection\_digest\_id, ledger\_paths:{[}\ldots{]}\} â”‚ â”‚ â””â”€â†’ Append JSON
line to /multi-agent/logs/final\_status/phase7.jsonl â”‚ â”‚ â”‚ â”‚ Step 4:
Emit Planning/Reporting Event â”‚ â”‚ â”œâ”€â†’ Publish compact summary â†’
/reports/final\_events.jsonl â”‚ â”‚ â”‚ \{task\_id, final\_status,
key\_metrics, missing\_gaps{[}{]}\} â”‚ â”‚ â””â”€â†’ Used by Phase 8 and Planning
Phase 1 (next cycle) â”‚ â”‚ â”‚ â”‚ Step 5: Memory Hooks (non-blocking) â”‚ â”‚ â”œâ”€â†’
If final\_status in \{``failed\_final'',``failed''\} and â”‚ â”‚ â”‚ repeated
root cause â†’ update /memory/semantic.yml rule â”‚ â”‚ â””â”€â†’ If ``completed''
with strong uplift â†’ cache template in â”‚ â”‚ /memory/procedural\_cache/ â”‚
â”‚ â”‚ â”‚ END FOR EACH â”‚ â”‚ â”‚ â”‚ OUTPUT: Finalized task\_results (terminal,
auditable) â”‚ â”‚ task\_results = {[} â”‚ â”‚ \{task\_id: 1,
status:``completed'', status\_reason:``Approved + evidence verified''\},
â”‚ â”‚ \{task\_id: 2, status:``failed\_final'', status\_reason:``Evidence
missing after max retries''\}, â”‚ â”‚ \{task\_id: 3, status:``failed'',
status\_reason:``Did not pass 3-agent approval gate''\} â”‚ â”‚ {]} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
Phase 8: REPORTING \& HANDOFF â”‚ â”‚ Cells 14, 16, 19 -- Generate Reports
and Trigger Next Cycle â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parallel Reflection Snapshot (non-blocking) â€¢ Roll up reflections â†’
reflection\_summary.md â€¢ Update memory: semantic.yml (rules),
procedural\_cache/ (templates)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â†“ â”‚
Step 1: Aggregate Results â”‚ â”‚ â”œâ”€â†’ Collect finalized task\_results from
Phase 7 (canonical JSON) â”‚ â”‚ â”œâ”€â†’ Join with run ledger, MLflow metadata,
artifacts index â”‚ â”‚ â””â”€â†’ Compute KPIs: completed\%, retry\_success\%,
evidence\_rate, â”‚ â”‚ avg\_attempts\_to\_success, top\_root\_causes â”‚ â”‚ â”‚
â”‚ Step 2: Generate Reports â”‚ â”‚ â”œâ”€â†’ Write machine report:
/reports/execution\_summary/summary.jsonâ”‚ â”‚ â”œâ”€â†’ Write human report:
/reports/execution\_summary/report.md(PDF)â”‚ â”‚ â”œâ”€â†’ Include links: MLflow
runs, artifact manifests, log bundles â”‚ â”‚ â””â”€â†’ Attach
reflection\_summary.md (patterns, fixes, confidence) â”‚ â”‚ â”‚ â”‚ Step 3:
Archive Logs \& Artifacts â”‚ â”‚ â”œâ”€â†’ Bundle
/logs/execution\_cycles/cycle\_N â†’ tar.gz + checksum â”‚ â”‚ â”œâ”€â†’ Snapshot
/multi-agent/ledgers/*.jsonl (immutable) â”‚ â”‚ â”œâ”€â†’ Persist artifact
manifest with sizes and SHA256 â”‚ â”‚ â””â”€â†’ Record retention window \& access
policy â”‚ â”‚ â”‚ â”‚ Step 4: Memory Promotion (Learning) â”‚ â”‚ â”œâ”€â†’ From
reflections.jsonl â†’ update /memory/semantic.yml (rules) â”‚ â”‚ â”œâ”€â†’ Promote
stable job\_specs â†’ /memory/procedural\_cache/ â”‚ â”‚ â””â”€â†’ Prune
/memory/episodic.jsonl to top-K recent per task â”‚ â”‚ â”‚ â”‚ Step 5:
Governance \& Redaction Checks â”‚ â”‚ â”œâ”€â†’ PII/secret scan on reports \&
logs; redact or block as needed â”‚ â”‚ â”œâ”€â†’ Verify schema versions \&
provenance IDs across outputs â”‚ â”‚ â””â”€â†’ Sign summary.json + report.md with
release tag (vX.Y.cycleN) â”‚ â”‚ â”‚ â”‚ Step 6: Trigger Next Planning Cycle â”‚
â”‚ â”œâ”€â†’ Compose /reports/handoff/pending\_actions.json (vNext) â”‚ â”‚ â”‚ â€¢
include unresolved/failed\_final tasks with reasons â”‚ â”‚ â”‚ â€¢ include
pre-patch hints from semantic.yml â”‚ â”‚ â”œâ”€â†’ Write handoff manifest:
\{version, checksums, URIs, counts\} â”‚ â”‚ â””â”€â†’ Notify Planning Team:
``Execution cycle complete'' â”‚ â”‚ â”‚ â”‚ OUTPUT: â”‚ â”‚ â€¢ summary.json,
report.md/PDF, reflection\_summary.md â”‚ â”‚ â€¢ updated memory:
semantic.yml, procedural\_cache/, episodic.jsonlâ”‚ â”‚ â€¢ archived
logs/artifacts with checksums â”‚ â”‚ â€¢ handoff: pending\_actions.json (for
Phase 1: Planning) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

\end{document}
